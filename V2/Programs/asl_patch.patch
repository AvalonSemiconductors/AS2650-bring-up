diff --git a/Makefile.def.tmpl b/Makefile.def.tmpl
deleted file mode 100644
index 605e4a7..0000000
--- a/Makefile.def.tmpl
+++ /dev/null
@@ -1,32 +0,0 @@
-# -------------------------------------------------------------------------
-# choose your compiler (must be ANSI-compliant!) and linker command, plus
-# any additionally needed flags
-
-CC = gcc
-LD = gcc
-CFLAGS = -O3 -fomit-frame-pointer -Wall
-LDFLAGS =
-
-TARG_OBJEXTENSION = .o
-TARG_EXEXTENSION =
-
-HOST_OBJEXTENSION = $(TARG_OBJEXTENSION)
-HOST_EXEXTENSION = $(TARG_EXEXTENSION)
-
-# -------------------------------------------------------------------------
-# directories where binaries, includes, and manpages should go during
-# installation
-
-BINDIR = /usr/local/bin
-INCDIR = /usr/local/include/asl
-MANDIR = /usr/local/man
-LIBDIR = /usr/local/lib/asl
-DOCDIR = /usr/local/doc/asl
-
-# -------------------------------------------------------------------------
-# character encoding to use (choose one of them)
-
-# CHARSET = CHARSET_ASCII7
-# CHARSET = CHARSET_IBM437
-# CHARSET = CHARSET_UTF8
-CHARSET = CHARSET_ISO8859_1
diff --git a/Makefile.dep b/Makefile.dep
index b23237f..939370f 100644
--- a/Makefile.dep
+++ b/Makefile.dep
@@ -2,7 +2,7 @@
 
 alink.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h version.h endian.h bpemu.h strutil.h nls.h nlmessages.h stringlists.h cmdarg.h toolutils.h fileformat.h asmerr.h ioerrs.h alink.rsc
 
-as.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h version.h endian.h bpemu.h stdhandl.h nls.h nlmessages.h as.rsc ioerrs.h strutil.h stringlists.h cmdarg.h asmitree.h trees.h chunks.h asminclist.h asmfnums.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h errmsg.h asmsub.h asmerr.h asmpars.h asmmac.h asmstructs.h asmif.h asmcode.h asmdebug.h asmrelocs.h asmallg.h codepseudo.h as.h code68k.h code56k.h code601.h codemcore.h codexgate.h code68.h code6805.h code6809.h code6812.h codes12z.h code6816.h code68rs08.h codeh8_3.h codeh8_5.h code7000.h code65.h code7700.h codehmcs400.h code4500.h codem16.h codem16c.h code4004.h code8008.h code48.h code51.h code96.h code85.h code86.h code960.h code8x30x.h code2650.h codexa.h codeavr.h code29k.h code166.h codez80.h codez8.h codekcpsm.h codekcp3.h codemic8.h code96c141.h code90c141.h code87c800.h code870c.h code47c00.h code97c241.h code9331.h code16c5x.h code16c8x.h code17c4x.h codesx20.h codest6.h codest7.h codest9.h code6804.h code3201x.h code3202x.h code3203x.h code3205x.h code3254x.h code3206x.h code9900.h codetms7.h code370.h codemsp.h codetms1.h codescmp.h code807x.h codecop4.h codecop8.h codesc14xxx.h codeace.h codef8.h code78c10.h code75xx.h code75k0.h code78k0.h code78k2.h code78k3.h code78k4.h code7720.h code77230.h code53c8xx.h codefmc8.h codefmc16.h codeol40.h codeol50.h code1802.h codevector.h codexcore.h code1750.h
+as.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h version.h endian.h bpemu.h stdhandl.h nls.h nlmessages.h as.rsc ioerrs.h strutil.h stringlists.h cmdarg.h asmitree.h trees.h chunks.h asminclist.h asmfnums.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h errmsg.h asmsub.h asmerr.h asmpars.h asmmac.h asmstructs.h asmif.h asmcode.h asmdebug.h asmrelocs.h asmallg.h codepseudo.h as.h code68k.h code56k.h code601.h codemcore.h codexgate.h code68.h code6805.h code6809.h code6812.h codes12z.h code6816.h code68rs08.h codeh8_3.h codeh8_5.h code7000.h code65.h code7700.h codehmcs400.h code4500.h codem16.h codem16c.h code4004.h code8008.h code48.h code51.h code96.h code85.h code86.h code960.h code8x30x.h code2650.h codeas2650-2.h codexa.h codeavr.h code29k.h code166.h codez80.h codez8.h codekcpsm.h codekcp3.h codemic8.h code96c141.h code90c141.h code87c800.h code870c.h code47c00.h code97c241.h code9331.h code16c5x.h code16c8x.h code17c4x.h codesx20.h codest6.h codest7.h codest9.h code6804.h code3201x.h code3202x.h code3203x.h code3205x.h code3254x.h code3206x.h code9900.h codetms7.h code370.h codemsp.h codetms1.h codescmp.h code807x.h codecop4.h codecop8.h codesc14xxx.h codeace.h codef8.h code78c10.h code75xx.h code75k0.h code78k0.h code78k2.h code78k3.h code78k4.h code7720.h code77230.h code53c8xx.h codefmc8.h codefmc16.h codeol40.h codeol50.h code1802.h codevector.h codexcore.h code1750.h codeqcpu.h
 
 asmallg.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h strutil.h stringlists.h bpemu.h cmdarg.h chunks.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h errmsg.h as.h as.rsc asmpars.h asmmac.h asmstructs.h asmcode.h asmrelocs.h asmitree.h codepseudo.h nlmessages.h
 
@@ -84,8 +84,6 @@ code601.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h endian.h struti
 
 code65.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmsub.h asmerr.h asmitree.h codepseudo.h motpseudo.h codevars.h errmsg.h code65.h
 
-code68.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmallg.h asmsub.h asmerr.h errmsg.h codepseudo.h motpseudo.h asmitree.h codevars.h nlmessages.h as.rsc code68.h
-
 code6804.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h motpseudo.h codevars.h errmsg.h code6804.h
 
 code6805.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmsub.h asmerr.h asmitree.h motpseudo.h codevars.h errmsg.h code6805.h
@@ -96,6 +94,8 @@ code6812.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h strutil.h bpem
 
 code6816.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h nlmessages.h as.rsc bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h errmsg.h asmpars.h asmitree.h codepseudo.h motpseudo.h codevars.h code6816.h
 
+code68.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmallg.h asmsub.h asmerr.h errmsg.h codepseudo.h motpseudo.h asmitree.h codevars.h nlmessages.h as.rsc code68.h
+
 code68k.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h bpemu.h endian.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h motpseudo.h asmitree.h codevars.h intconsts.h errmsg.h code68k.h
 
 code68rs08.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmsub.h asmerr.h asmitree.h motpseudo.h codevars.h errmsg.h code68rs08.h
@@ -140,10 +140,10 @@ code90c141.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h bpemu.
 
 code9331.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h headids.h codevars.h errmsg.h code9331.h
 
-code96.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h errmsg.h code96.h
-
 code960.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h endian.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h asmitree.h codevars.h intpseudo.h headids.h intconsts.h errmsg.h code960.h
 
+code96.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h errmsg.h code96.h
+
 code96c141.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h errmsg.h codepseudo.h intpseudo.h asmitree.h codevars.h code96c141.h
 
 code97c241.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h errmsg.h code97c241.h
@@ -152,6 +152,8 @@ code9900.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h strutil.h endi
 
 codeace.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h chunks.h headids.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h errmsg.h codeace.h
 
+codeas2650-2.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h chunks.h bpemu.h strutil.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codevars.h headids.h intpseudo.h errmsg.h codeas2650-2.h
+
 codeavr.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h nls.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h asmitree.h codepseudo.h codevars.h errmsg.h codeavr.h
 
 codechunks.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h codechunks.h
@@ -192,6 +194,8 @@ codeol50.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h struti
 
 codepseudo.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h bpemu.h endian.h strutil.h chunks.h asmdef.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h asmitree.h errmsg.h codepseudo.h motpseudo.h
 
+codeqcpu.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h bpemu.h strutil.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codevars.h headids.h fourpseudo.h errmsg.h codeqcpu.h
+
 codes12z.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmpars.h asmsub.h asmerr.h asmallg.h asmitree.h asmstructs.h codepseudo.h motpseudo.h codevars.h errmsg.h headids.h codes12z.h
 
 codesc14xxx.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h codepseudo.h headids.h asmitree.h codevars.h errmsg.h codesc14xxx.h
@@ -220,10 +224,10 @@ codexcore.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h endian.
 
 codexgate.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h endian.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmallg.h headids.h codepseudo.h motpseudo.h asmitree.h codevars.h errmsg.h codexgate.h
 
-codez8.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h headids.h errmsg.h codez8.h
-
 codez80.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmcode.h asmallg.h asmitree.h codepseudo.h intpseudo.h codevars.h intconsts.h errmsg.h codez80.h
 
+codez8.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nls.h strutil.h bpemu.h asmdef.h chunks.h fileformat.h dynstring.h strcomp.h lstmacroexp.h cpulist.h tempresult.h asmsub.h asmerr.h asmpars.h asmitree.h codepseudo.h intpseudo.h codevars.h headids.h errmsg.h codez8.h
+
 cpulist.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h strutil.h cpulist.h
 
 das.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h nlmessages.h stringlists.h codechunks.h entryaddress.h invaddress.h strutil.h cmdarg.h dasmdef.h chunks.h cpulist.h das.rsc deco68.h deco87c800.h
@@ -310,4 +314,4 @@ unumlaut.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h strutil.h
 
 version.o: stdinc.h pascstyle.h datatypes.h sysdefs.h chardefs.h
 
-Makefile.dep: a2k.c addcr.c alink.c as.c asmallg.c asmcode.c asmdebug.c asmdef.c asmfnums.c asmif.c asminclist.c asmitree.c asmmac.c asmpars.c asmrelocs.c asmstructs.c asmsub.c bincmp.c bpemu.c chunks.c cmdarg.c code166.c code16c5x.c code16c8x.c code1750.c code17c4x.c code1802.c code2650.c code29k.c code3201x.c code3202x.c code3203x.c code3205x.c code3206x.c code3254x.c code370.c code4004.c code4500.c code47c00.c code48.c code51.c code53c8xx.c code56k.c code601.c code65.c code68.c code6804.c code6805.c code6809.c code6812.c code6816.c code68k.c code68rs08.c code7000.c code75k0.c code75xx.c code7700.c code7720.c code77230.c code78c10.c code78k0.c code78k2.c code78k3.c code78k4.c code8008.c code807x.c code85.c code86.c code870c.c code87c800.c code8x30x.c code90c141.c code9331.c code96.c code960.c code96c141.c code97c241.c code9900.c codeace.c codeavr.c codechunks.c codecop4.c codecop8.c codef8.c codefmc16.c codefmc8.c codeh8_3.c codeh8_5.c codehmcs400.c codekcp3.c codekcpsm.c codem16.c codem16c.c codemcore.c codemic8.c codemsp.c codeol40.c codeol50.c codepseudo.c codes12z.c codesc14xxx.c codescmp.c codest6.c codest7.c codest9.c codesx20.c codetms1.c codetms7.c codevars.c codevector.c codexa.c codexcore.c codexgate.c codez8.c codez80.c cpulist.c das.c dasmdef.c debversion.c deco68.c deco87c800.c dynstring.c endian.c entryaddress.c errmsg.c findhyphen.c fourpseudo.c function.c grhyph.c headids.c hex.c intpseudo.c invaddress.c ioerrs.c lstmacroexp.c mkdepend.c motpseudo.c natpseudo.c nlmessages.c nls.c operator.c p2bin.c p2hex.c pbind.c plist.c rescomp.c stdhandl.c strcomp.c stringlists.c strutil.c tempresult.c tex2doc.c tex2html.c tipseudo.c toolutils.c trees.c umlaut.c unumlaut.c ushyph.c version.c
+Makefile.dep: a2k.c addcr.c alink.c as.c asmallg.c asmcode.c asmdebug.c asmdef.c asmfnums.c asmif.c asminclist.c asmitree.c asmmac.c asmpars.c asmrelocs.c asmstructs.c asmsub.c bincmp.c bpemu.c chunks.c cmdarg.c code166.c code16c5x.c code16c8x.c code1750.c code17c4x.c code1802.c code2650.c code29k.c code3201x.c code3202x.c code3203x.c code3205x.c code3206x.c code3254x.c code370.c code4004.c code4500.c code47c00.c code48.c code51.c code53c8xx.c code56k.c code601.c code65.c code6804.c code6805.c code6809.c code6812.c code6816.c code68.c code68k.c code68rs08.c code7000.c code75k0.c code75xx.c code7700.c code7720.c code77230.c code78c10.c code78k0.c code78k2.c code78k3.c code78k4.c code8008.c code807x.c code85.c code86.c code870c.c code87c800.c code8x30x.c code90c141.c code9331.c code960.c code96.c code96c141.c code97c241.c code9900.c codeace.c codeas2650-2.c codeavr.c codechunks.c codecop4.c codecop8.c codef8.c codefmc16.c codefmc8.c codeh8_3.c codeh8_5.c codehmcs400.c codekcp3.c codekcpsm.c codem16.c codem16c.c codemcore.c codemic8.c codemsp.c codeol40.c codeol50.c codepseudo.c codeqcpu.c codes12z.c codesc14xxx.c codescmp.c codest6.c codest7.c codest9.c codesx20.c codetms1.c codetms7.c codevars.c codevector.c codexa.c codexcore.c codexgate.c codez80.c codez8.c cpulist.c das.c dasmdef.c debversion.c deco68.c deco87c800.c dynstring.c endian.c entryaddress.c errmsg.c findhyphen.c fourpseudo.c function.c grhyph.c headids.c hex.c intpseudo.c invaddress.c ioerrs.c lstmacroexp.c mkdepend.c motpseudo.c natpseudo.c nlmessages.c nls.c operator.c p2bin.c p2hex.c pbind.c plist.c rescomp.c stdhandl.c strcomp.c stringlists.c strutil.c tempresult.c tex2doc.c tex2html.c tipseudo.c toolutils.c trees.c umlaut.c unumlaut.c ushyph.c version.c
diff --git a/as.c b/as.c
index 14c4c37..6d9e9a4 100644
--- a/as.c
+++ b/as.c
@@ -416,6 +416,7 @@
 #include "code960.h"
 #include "code8x30x.h"
 #include "code2650.h"
+#include "codeas2650-2.h"
 #include "codexa.h"
 #include "codeavr.h"
 #include "code29k.h"
@@ -476,6 +477,7 @@
 #include "codevector.h"
 #include "codexcore.h"
 #include "code1750.h"
+#include "codeqcpu.h"
 /**          Code21xx};**/
 
 static char *FileMask;
@@ -4639,6 +4641,8 @@ int main(int argc, char **argv)
     code960_init();
     code8x30x_init();
     code2650_init();
+    code_qcpu_init();
+    codeas2650_init();
     codexa_init();
     codeavr_init();
     code29k_init();
diff --git a/codeas2650-2.c b/codeas2650-2.c
new file mode 100644
index 0000000..e3bb47e
--- /dev/null
+++ b/codeas2650-2.c
@@ -0,0 +1,559 @@
+/* codeas2650-2.c */
+
+#include "stdinc.h"
+#include <string.h>
+#include <ctype.h>
+
+#include "nls.h"
+#include "chunks.h"
+#include "bpemu.h"
+#include "strutil.h"
+
+#include "asmdef.h"
+#include "asmsub.h"
+#include "asmpars.h"
+#include "asmitree.h"
+#include "codevars.h"
+#include "headids.h"
+#include "intpseudo.h"
+#include "errmsg.h"
+
+#include "codeas2650-2.h"
+
+static CPUVar CPUAS2650;
+
+static Boolean DecodeReg(const char *pAsc, Byte *pRes, char *modifier) {
+	Boolean Result;
+	*modifier = 0;
+	int aaa = strlen(pAsc);
+	if(aaa == 3) {
+		*modifier = pAsc[2];
+	}
+	
+	Result = ((aaa == 2 || aaa == 3) && (mytoupper(pAsc[0]) == 'R') && (pAsc[1] >= '0') && (pAsc[1] <= '3'));
+	if(Result) *pRes = pAsc[1] - '0';
+	return Result;
+}
+
+static Boolean DecodeCondition(const char *pAsc, Byte *pRes) {
+	Boolean Result = TRUE;
+	
+	if(!strcasecmp(pAsc, "EQ") || !strcasecmp(pAsc, "0")) *pRes = 0;
+	else if(!strcasecmp(pAsc, "GT") || !strcasecmp(pAsc, "1")) *pRes = 1;
+	else if(!strcasecmp(pAsc, "LT") || !strcasecmp(pAsc, "2")) *pRes = 2;
+	else if((!strcasecmp(pAsc, "ALWAYS")) || (!strcasecmp(pAsc, "UN"))) *pRes = 3;
+	else Result = FALSE;
+	
+	return Result;
+}
+
+static void DecodeFixed(Word Index) {
+	if(ChkArgCnt(0, 0)) {
+		CodeLen = 0;
+		if((Index & 16384) != 0) {
+			BAsmCode[CodeLen] = 0xB7;
+			CodeLen++;
+			Index &= 0xFF;
+		}
+		BAsmCode[CodeLen] = Index;
+		CodeLen++;
+	}
+}
+
+static void DecodeOneReg(Word Index) {
+	Byte Reg;
+	char mod = 0;
+	
+	if(!ChkArgCnt(1, 1));
+	else if(!DecodeReg(ArgStr[1].Str, &Reg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		CodeLen = 0;
+		if((Index & 16384) != 0) {
+			BAsmCode[CodeLen] = 0xB7;
+			CodeLen++;
+			Index &= 0xFF;
+		}
+		BAsmCode[CodeLen] = Index | Reg;
+		CodeLen++;
+	}
+}
+
+static void DecodeImm(Word Index) {
+	Boolean OK;
+	
+	if(ChkArgCnt(1, 1)) {
+		BAsmCode[1] = EvalStrIntExpression(&ArgStr[1], Int8, &OK);
+		if(OK) {
+			BAsmCode[0] = Index;
+			CodeLen = 2;
+		}
+	}
+}
+
+static void DecodeRegImm(Word Index) {
+	Byte Reg;
+	Boolean OK;
+	char mod;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeReg(ArgStr[1].Str, &Reg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		BAsmCode[1] = EvalStrIntExpression(&ArgStr[2], Int8, &OK);
+		if(OK) {
+			BAsmCode[0] = Index | Reg;
+			CodeLen = 2;
+		}
+	}
+}
+
+static void DecodeRegAbs(Word Index) {
+	Byte DReg, IReg;
+	Word AbsVal;
+	Boolean OK, IndFlag;
+	char mod;
+	
+	if(!ChkArgCnt(2, 4));
+	else if(!DecodeReg(ArgStr[1].Str, &DReg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		IndFlag = *ArgStr[2].Str == '*';
+		AbsVal = EvalStrIntExpressionOffs(&ArgStr[2], IndFlag, UInt16, &OK);
+		if(!OK) return;
+		
+		if((AbsVal & 0xE000) != (EProgCounter() & 0xE000)) {
+			WrError(ErrNum_InvAddrMode);
+			return;
+		}
+		AbsVal &= 0x1FFF;
+		
+		BAsmCode[0] = Index;
+		BAsmCode[1] = Hi(AbsVal);
+		BAsmCode[2] = Lo(AbsVal);
+		if(IndFlag) BAsmCode[1] |= 0x80;
+		if(ArgCnt == 2) {
+			BAsmCode[0] |= DReg;
+			CodeLen = 3;
+		}else {
+			if(!DecodeReg(ArgStr[3].Str, &IReg, &mod)) WrStrErrorPos(ErrNum_InvReg, &ArgStr[3]);
+			else if (DReg != 0) WrError(ErrNum_InvAddrMode);
+			else {
+				BAsmCode[0] |= IReg;
+				if(mod == 0) {
+					BAsmCode[1] |= 0x60;
+					CodeLen = 3;
+				}
+				else if(mod == '-') {
+					BAsmCode[1] |= 0x40;
+					CodeLen = 3;
+				}else if(mod == '+') {
+					BAsmCode[1] |= 0x20;
+					CodeLen = 3;
+				}else WrError(ErrNum_InvAddrMode);
+			}
+		}
+	}
+}
+
+static void DecodeRegRel(Word Index) {
+	Byte Reg;
+	Boolean IndFlag, OK;
+	int Dist;
+	char mod;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeReg(ArgStr[1].Str, &Reg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		BAsmCode[0] = Index | Reg;
+		IndFlag = *ArgStr[2].Str == '*';
+		Dist = EvalStrIntExpressionOffs(&ArgStr[2], IndFlag, UInt15, &OK) - (EProgCounter() + 2);
+		if(OK) {
+			if(((Dist < - 64) || (Dist > 63)) && (!SymbolQuestionable)) WrError(ErrNum_JmpDistTooBig);
+			else {
+				BAsmCode[1] = Dist & 0x7f;
+				if(IndFlag) BAsmCode[1] |= 0x80;
+				CodeLen = 2;
+			}
+		}
+	}
+}
+
+static void DecodeCondAbs(Word Index) {
+	Byte Cond;
+	Word Address;
+	Boolean OK, IndFlag;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeCondition(ArgStr[1].Str, &Cond)) WrStrErrorPos(ErrNum_UndefCond, &ArgStr[1]);
+	else {
+		IndFlag = *ArgStr[2].Str == '*';
+		Address = EvalStrIntExpressionOffs(&ArgStr[2], IndFlag, UInt16, &OK);
+		if(OK) {
+			if((Address & 0x8000) != (EProgCounter() & 0x8000)) {
+				WrError(ErrNum_InvAddrMode);
+				return;
+			}
+			Address &= 0x7FFF;
+			BAsmCode[0] = Index | Cond;
+			BAsmCode[1] = Hi(Address);
+			if(IndFlag) BAsmCode[1] |= 0x80;
+			BAsmCode[2] = Lo(Address);
+			CodeLen = 3;
+		}
+	}
+}
+
+static void DecodeCondFar(Word Index) {
+	Byte Cond;
+	Word Address;
+	Boolean OK;
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeCondition(ArgStr[1].Str, &Cond)) WrStrErrorPos(ErrNum_UndefCond, &ArgStr[1]);
+	else {
+		Address = EvalStrIntExpressionOffs(&ArgStr[2], 0, UInt16, &OK);
+		if(OK) {
+			BAsmCode[0] = 0xB7;
+			BAsmCode[1] = Index | Cond;
+			BAsmCode[2] = Hi(Address);
+			BAsmCode[3] = Lo(Address);
+			CodeLen = 4;
+		}
+	}
+}
+
+static void DecodeCondRel(Word Index) {
+	Byte Cond;
+	Boolean IndFlag, OK;
+	int Dist;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeCondition(ArgStr[1].Str, &Cond)) WrStrErrorPos(ErrNum_UndefCond, &ArgStr[1]);
+	else {
+		BAsmCode[0] = Index | Cond;
+		IndFlag = *ArgStr[2].Str == '*';
+		Dist = EvalStrIntExpressionOffs(&ArgStr[2], IndFlag, UInt15, &OK) - (EProgCounter() + 2);
+		if(OK) {
+			if(((Dist < - 64) || (Dist > 63)) && (!SymbolQuestionable)) WrError(ErrNum_JmpDistTooBig);
+			else {
+				BAsmCode[1] = Dist & 0x7f;
+				if(IndFlag) BAsmCode[1] |= 0x80;
+				CodeLen = 2;
+			}
+		}
+	}
+}
+
+static void DecodeRegAbs2(Word Index) {
+	Byte Reg;
+	Word AbsVal;
+	Boolean IndFlag, OK;
+	char mod;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeReg(ArgStr[1].Str, &Reg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		BAsmCode[0] = Index | Reg;
+		IndFlag = *ArgStr[2].Str == '*';
+		AbsVal = EvalStrIntExpressionOffs(&ArgStr[2], IndFlag, UInt16, &OK);
+		if((AbsVal & 0x8000) != (EProgCounter() & 0x8000)) {
+			WrError(ErrNum_InvAddrMode);
+			return;
+		}
+		AbsVal &= 0x7FFF;
+		if(OK) {
+			BAsmCode[1] = Hi(AbsVal);
+			if(IndFlag) BAsmCode[1] |= 0x80;
+			BAsmCode[2] = Lo(AbsVal);
+			CodeLen = 3;
+		}
+	}
+}
+
+static void DecodeRegFar(Word Index) {
+	Byte Reg;
+	Word AbsVal;
+	Boolean OK;
+	char mod;
+	
+	if(!ChkArgCnt(2, 2));
+	else if(!DecodeReg(ArgStr[1].Str, &Reg, &mod) || mod != 0) WrStrErrorPos(ErrNum_InvReg, &ArgStr[1]);
+	else {
+		BAsmCode[0] = Index | Reg;
+		AbsVal = EvalStrIntExpressionOffs(&ArgStr[2], 0, UInt16, &OK);
+		if(OK) {
+			BAsmCode[1] = Hi(AbsVal);
+			BAsmCode[2] = Lo(AbsVal);
+			CodeLen = 3;
+		}
+	}
+}
+
+static void DecodeBrAbs(Word Index) {
+	Byte Reg = 3;
+	Word AbsVal;
+	Boolean IndFlag, OK;
+	char mod;
+	
+	if(!ChkArgCnt(1, 2));
+	else if((ArgCnt == 2) && (!DecodeReg(ArgStr[2].Str, &Reg, &mod) || mod != 0)) WrStrErrorPos(ErrNum_InvReg, &ArgStr[2]);
+	else if(Reg != 3) WrError(ErrNum_InvAddrMode);
+	else {
+		BAsmCode[0] = Index | Reg;
+		IndFlag = *ArgStr[1].Str == '*';
+		AbsVal = EvalStrIntExpressionOffs(&ArgStr[1], IndFlag, UInt13, &OK);
+		if(OK) {
+			BAsmCode[1] = Hi(AbsVal);
+			if(IndFlag) BAsmCode[1] |= 0x80;
+			BAsmCode[2] = Lo(AbsVal);
+			CodeLen = 3;
+		}
+	}
+}
+
+static void DecodeCond(Word Index) {
+	Byte Cond;
+	
+	if(!ChkArgCnt(1, 1));
+	else if(!DecodeCondition(ArgStr[1].Str, &Cond)) WrStrErrorPos(ErrNum_UndefCond, &ArgStr[1]);
+	else {
+		BAsmCode[0] = Index | Cond;
+		CodeLen = 1;
+	}
+}
+
+static void DecodeZero(Word Index) {
+	Boolean IndFlag, OK;
+	
+	if(ChkArgCnt(1, 1)) {
+		BAsmCode[0] = Index;
+		IndFlag = *ArgStr[1].Str == '*';
+		BAsmCode[1] = EvalStrIntExpressionOffs(&ArgStr[1], IndFlag, UInt7, &OK);
+		if(!OK) return;
+		if(IndFlag) BAsmCode[1] |= 0x80; 
+		CodeLen = 2;
+	}
+}
+
+static void AddFixed(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code | (Extended ? 16384 : 0), DecodeFixed);
+}
+
+static void AddOneReg(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code | (Extended ? 16384 : 0), DecodeOneReg);
+}
+
+static void AddImm(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeImm);
+}
+
+static void AddRegImm(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeRegImm);
+}
+
+static void AddRegAbs(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeRegAbs);
+}
+
+static void AddRegRel(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeRegRel);
+}
+
+static void AddCondAbs(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeCondAbs);
+}
+
+static void AddCondRel(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeCondRel);
+}
+
+static void AddRegAbs2(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeRegAbs2);
+}
+   
+static void AddBrAbs(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeBrAbs);
+}  
+
+static void AddCond(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeCond);
+}
+
+static void AddZero(char *pName, Word Code, Boolean Extended) {
+	AddInstTable(InstTable, pName, Code, DecodeZero);
+}
+
+static void AddCondFar(char *pName, Word Code) {
+	AddInstTable(InstTable, pName, Code, DecodeCondFar);
+}
+
+static void AddRegFar(char *pName, Word Code) {
+	AddInstTable(InstTable, pName, Code, DecodeRegFar);
+}
+
+static void InitFields(void) {
+	InstTable = CreateInstTable(203);
+	
+	AddFixed("NOP", 0xc0, FALSE);
+	AddFixed("HALT", 0x40, FALSE);
+	AddFixed("LPSL", 0x93, FALSE);
+	AddFixed("LPSU", 0x92, FALSE);
+	AddFixed("SPSL", 0x13, FALSE);
+	AddFixed("SPSU", 0x12, FALSE);
+	AddFixed("MUL", 0x90, FALSE);
+	AddFixed("XCHG", 0x91, FALSE);
+	AddFixed("TRAP", 0x90, TRUE);
+	AddFixed("CLRT", 0x91, TRUE);
+	AddFixed("PSHS", 0x10, TRUE);
+	AddFixed("POPS", 0x11, TRUE);
+	AddFixed("SVB", 0x12, TRUE);
+	AddFixed("CHRP", 0x13, TRUE);
+	AddFixed("LIR", 0x92, TRUE);
+	AddFixed("SIR", 0x93, TRUE);
+	
+	AddOneReg("ADDZ", 0x80, FALSE);
+	AddOneReg("ANDZ", 0x40, FALSE);
+	AddOneReg("COMZ", 0xe0, FALSE);
+	AddOneReg("DAR", 0x94, FALSE);
+	AddOneReg("EORZ", 0x20, FALSE);
+	AddOneReg("IORZ", 0x60, FALSE);
+	AddOneReg("LODZ", 0x00, FALSE);
+	AddOneReg("REDC", 0x30, FALSE);
+	AddOneReg("REDD", 0x70, FALSE);
+	AddOneReg("RRL", 0xd0, FALSE);
+	AddOneReg("RRR", 0x50, FALSE);
+	AddOneReg("STRZ", 0xc0, FALSE);
+	AddOneReg("SUBZ", 0xa0, FALSE);
+	AddOneReg("WRTC", 0xb0, FALSE);
+	AddOneReg("WRTD", 0xf0, FALSE);
+	AddOneReg("CLR", 0xc4, FALSE);
+	AddOneReg("CPL", 0xe0, TRUE);
+	
+	AddImm("CPSL", 0x75, FALSE);
+	AddImm("CPSU", 0x74, FALSE);
+	AddImm("PPSL", 0x77, FALSE);
+	AddImm("PPSU", 0x76, FALSE);
+	AddImm("TPSL", 0xb5, FALSE);
+	AddImm("TPSU", 0xb4, FALSE);
+	
+	AddRegImm("ADDI", 0x84, FALSE);
+	AddRegImm("ANDI", 0x44, FALSE);
+	AddRegImm("COMI", 0xe4, FALSE);
+	AddRegImm("EORI", 0x24, FALSE);
+	AddRegImm("IORI", 0x64, FALSE);
+	AddRegImm("LODI", 0x04, FALSE);
+	AddRegImm("REDE", 0x54, FALSE);
+	AddRegImm("SUBI", 0xa4, FALSE);
+	AddRegImm("TMI", 0xf4, FALSE);
+	AddRegImm("WRTE", 0xd4, FALSE);
+	
+	AddRegAbs("ADDA", 0x8c, FALSE);
+	AddRegAbs("ANDA", 0x4c, FALSE);
+	AddRegAbs("COMA", 0xec, FALSE);
+	AddRegAbs("EORA", 0x2c, FALSE);
+	AddRegAbs("IORA", 0x6c, FALSE);
+	AddRegAbs("LODA", 0x0c, FALSE);
+	AddRegAbs("STRA", 0xcc, FALSE);
+	AddRegAbs("SUBA", 0xac, FALSE);
+	
+	AddRegRel("ADDR", 0x88, FALSE);
+	AddRegRel("ANDR", 0x48, FALSE);
+	AddRegRel("BDRR", 0xf8, FALSE);
+	AddRegRel("BIRR", 0xd8, FALSE);
+	AddRegRel("BRNR", 0x58, FALSE);
+	AddRegRel("BSNR", 0x78, FALSE);
+	AddRegRel("COMR", 0xe8, FALSE);
+	AddRegRel("EORR", 0x28, FALSE);
+	AddRegRel("IORR", 0x68, FALSE);
+	AddRegRel("LODR", 0x08, FALSE);
+	AddRegRel("STRR", 0xc8, FALSE);
+	AddRegRel("SUBR", 0xa8, FALSE);
+	
+	AddCondAbs("BCFA", 0x9c, FALSE);
+	AddCondAbs("BCTA", 0x1c, FALSE);
+	AddCondAbs("BSFA", 0xbc, FALSE);
+	AddCondAbs("BSTA", 0x3c, FALSE);
+	
+	AddCondRel("BCFR", 0x98, FALSE);
+	AddCondRel("BCTR", 0x18, FALSE);
+	AddCondRel("BSFR", 0xb8, FALSE);
+	AddCondRel("BSTR", 0x38, FALSE);
+	
+	AddRegAbs2("BDRA", 0xfc, FALSE);
+	AddRegAbs2("BIRA", 0xdc, FALSE);
+	AddRegAbs2("BRNA", 0x5c, FALSE);
+	AddRegAbs2("BSNA", 0x7c, FALSE);
+	
+	AddBrAbs("BSXA", 0xbf, FALSE);
+	AddBrAbs("BXA", 0x9f, FALSE);
+	
+	AddCond("RETC", 0x14, FALSE);
+	AddCond("RETE", 0x34, FALSE);
+	
+	AddZero("ZBRR", 0x9b, FALSE);
+	AddZero("ZBSR", 0xbb, FALSE);
+	
+	AddCondFar("BCTF", 0x1c);
+	AddCondFar("BSTF", 0x3c);
+	AddCondFar("BCFF", 0x9c);
+	AddCondFar("BSFF", 0xbc);
+	
+	AddRegFar("BRNF", 0x5C);
+	AddRegFar("BSNF", 0x7C);
+	AddRegFar("BIRF", 0xDC);
+	AddRegFar("BDRF", 0xFC);
+}
+
+static void DeinitFields(void) {
+	DestroyInstTable(InstTable);
+}
+
+static void MakeCode_as2650(void) {
+	char *pPos;
+	CodeLen = 0;
+	DontPrint = False;
+	
+	if((*OpPart.Str == '\0') && (ArgCnt == 0)) return;
+	
+	if(DecodeIntelPseudo(False)) return;
+	
+	pPos = strchr(OpPart.Str, ',');
+	if(pPos) {
+		int ArgC;
+		
+		IncArgCnt();
+		for(ArgC = ArgCnt - 1; ArgC >= 1; ArgC--) {
+			StrCompCopy(&ArgStr[ArgC + 1], &ArgStr[ArgC]);
+		}
+		StrCompSplitRight(&OpPart, &ArgStr[1], pPos);
+	}
+	
+	if(!LookupInstTable(InstTable, OpPart.Str)) WrStrErrorPos(ErrNum_UnknownInstruction, &OpPart);
+}
+
+static Boolean IsDef_as2650(void) {
+	return FALSE;
+}
+
+static void SwitchFrom_as2650(void) {
+	DeinitFields();
+}
+
+static void SwitchTo_as2650(void) {
+	PFamilyDescr pDescr;
+	
+	TurnWords = False; ConstMode = ConstModeMoto; SetIsOccupied = False;
+	
+	pDescr = FindFamilyByName("AS2650-2");
+	PCSymbol = "$"; HeaderID = pDescr->Id; NOPCode = 0xc0;
+	DivideChars = ","; HasAttrs = False;
+	
+	ValidSegs = (1 << SegCode);
+	Grans[SegCode] = 1; ListGrans[SegCode] = 1; SegInits[SegCode] = 0;
+	SegLimits[SegCode] = 0xffffl;
+	
+	MakeCode = MakeCode_as2650; IsDef = IsDef_as2650;
+	
+	SwitchFrom = SwitchFrom_as2650; InitFields();
+}
+
+void codeas2650_init(void) {
+	CPUAS2650 = AddCPU("AS2650-2", SwitchTo_as2650);
+}
diff --git a/codeas2650-2.h b/codeas2650-2.h
new file mode 100644
index 0000000..22dbe4d
--- /dev/null
+++ b/codeas2650-2.h
@@ -0,0 +1,6 @@
+#ifndef _CODEAS2650_H
+#define _CODEAS2650_H
+/* codeas-22650.h */
+
+extern void codeas2650_init(void);
+#endif /* _CODEAS2650_H */
diff --git a/codeqcpu.c b/codeqcpu.c
new file mode 100644
index 0000000..30ff22a
--- /dev/null
+++ b/codeqcpu.c
@@ -0,0 +1,337 @@
+#include "stdinc.h"
+#include <ctype.h>
+#include <string.h>
+
+#include "bpemu.h"
+#include "strutil.h"
+#include "asmdef.h"
+#include "asmsub.h"
+#include "asmpars.h"
+#include "asmitree.h"
+#include "codevars.h"
+#include "headids.h"
+#include "fourpseudo.h"
+#include "errmsg.h"
+
+#include "codeqcpu.h"
+
+#define SUPPORT_IMMEDIATE 32768
+#define J_CODE 0
+
+static CPUVar CPUqcpu;
+
+static void DecodeFixed(Word Code) {
+  if(ChkArgCnt(0, 0)) {
+    WAsmCode[CodeLen++] = Code;
+    if(Memo("OPTION")) WrError(ErrNum_Obsolete);
+  }
+}
+
+static void DecodeSingleReg(Word Code) {
+	if(ChkArgCnt(1, 1)) {
+		if(ArgStr[1].Str[0] != 'r') WrError(ErrNum_InvFormat);
+		else {
+			Boolean OK;
+			StrCompCutLeft(&ArgStr[1], 1);
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[1], UInt4, &OK);
+			if(OK) {
+				WAsmCode[0] <<= 8;
+				WAsmCode[0] |= Code;
+				CodeLen = 1;
+			}
+		}
+	}
+}
+
+static void DecodeIOA(Word Code) {
+	if(ChkArgCnt(1, 1)) {
+		if(ArgStr[1].Str[0] == 'r') {
+			DecodeSingleReg(0x605F);
+		}else {
+			if(ArgStr[1].Str[0] != '#') WrError(ErrNum_InvFormat);
+			else {
+				StrCompCutLeft(&ArgStr[1], 1);
+				Boolean OK;
+				WAsmCode[0] = EvalStrIntExpression(&ArgStr[1], UInt8, &OK);
+				if(OK) {
+					WAsmCode[0] <<= 8;
+					WAsmCode[0] |= Code;
+					CodeLen = 1;
+				}
+			}
+		}
+	}
+}
+
+static void DecodeMul(Word Code) {
+	if(ChkArgCnt(2, 2)) {
+		if(strcasecmp(ArgStr[1].Str, "r1") != 0) WrError(ErrNum_InvFormat);
+		else {
+			Boolean OK;
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[2], UInt4, &OK);
+			if(OK) {
+				WAsmCode[0] <<= 8;
+				WAsmCode[0] |= Code;
+				CodeLen = 1;
+			}
+		}
+	}
+}
+
+static void DecodeJump(Word Code) {
+	if(ChkArgCnt(1, 1)) {
+		Boolean OK;
+		Word dest = EvalStrIntExpression(&ArgStr[1], UInt14, &OK);
+		if(OK) {
+			WAsmCode[0] = (dest >> 8) & 0x3F;
+			WAsmCode[0] |= (dest & 0xFF) << 8;
+			WAsmCode[0] |= Code;
+			CodeLen = 1;
+		}
+	}
+}
+
+static void DecodeBranch(Word Code) {
+	if(ChkArgCnt(1, 1)) {
+		Boolean OK;
+		int dest = EvalStrIntExpression(&ArgStr[1], UInt14, &OK) - EProgCounter();
+		if(!SymbolQuestionable && ((dest < -1024) || (dest > 1024))) WrError(ErrNum_JmpDistTooBig);
+		unsigned int destu = (unsigned int)dest;
+		if(OK) {
+			WAsmCode[0] = (destu >> 8) & 0x07;
+			WAsmCode[0] |= (destu & 0xFF) << 8;
+			WAsmCode[0] |= Code;
+			CodeLen = 1;
+		}
+	}
+}
+
+static void DecodeAri(Word Code) {
+	if(ChkArgCnt(2, 2)) {
+		if(ArgStr[1].Str[0] != 'r') WrError(ErrNum_InvFormat);
+		else {
+			StrCompCutLeft(&ArgStr[1], 1);
+			Boolean OK;
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[1], UInt4, &OK);
+			if(!OK) return;
+			WAsmCode[0] <<= 12;
+			if(ArgStr[2].Str[0] != 'r') {
+				if((Code & SUPPORT_IMMEDIATE) == 0) WrError(ErrNum_InvFormat);
+				else {
+					Code &= 0x7FFF;
+					Code |= 0x0008;
+				}
+			}else {
+				Code &= 0x7FFF;
+			}
+			StrCompCutLeft(&ArgStr[2], 1);
+			Word s2 = EvalStrIntExpression(&ArgStr[2], UInt4, &OK);
+			if(!OK) return;
+			WAsmCode[0] |= s2 << 8;
+			WAsmCode[0] |= Code;
+			CodeLen = 1;
+		}
+	}
+}
+
+static void DecodeCmp(Word Code) {
+	if(ChkArgCnt(2, 2)) {
+		if(strcasecmp(ArgStr[1].Str, "r1") == 0 && ArgStr[2].Str[0] == '#') {
+			Boolean OK;
+			StrCompCutLeft(&ArgStr[2], 1);
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[2], UInt4, &OK);
+			if(OK) {
+				WAsmCode[0] <<= 8;
+				WAsmCode[0] |= 0x905F;
+				CodeLen = 1;
+			}
+		}else {
+			DecodeAri(0x005E);
+		}
+	}
+}
+
+static void DecodeLoadstore(Word Code) {
+	if(ChkArgCnt(2, 2)) {
+		if(ArgStr[1].Str[0] != 'r') WrError(ErrNum_InvFormat);
+		else if(ArgStr[2].Str[0] != 'r') WrError(ErrNum_InvFormat);
+		else {
+			StrCompCutLeft(&ArgStr[1], 1);
+			StrCompCutLeft(&ArgStr[2], 1);
+			Boolean OK;
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[1], UInt4, &OK);
+			if(!OK) return;
+			WAsmCode[0] <<= 12;
+			char* p = strchr(ArgStr[2].Str, '(');
+			if(!p) {
+				WrError(ErrNum_InvFormat);
+				return;
+			}
+			tStrComp RegArg, DispArg;
+			StrCompSplitRef(&RegArg, &DispArg, &ArgStr[2], p);
+			if(!RegArg.Str || !DispArg.Str || DispArg.Str[strlen(DispArg.Str) - 1] != ')') {
+				WrError(ErrNum_InvFormat);
+				return;
+			}
+			StrCompShorten(&DispArg, 1);
+			Word reg = EvalStrIntExpression(&RegArg, UInt4, &OK);
+			if(!OK) return;
+			WAsmCode[0] |= reg << 8;
+			WAsmCode[0] |= EvalStrIntExpression(&DispArg, UInt6, &OK);
+			if(!OK) return;
+			WAsmCode[0] |= Code;
+			CodeLen = 1;
+		}
+	}
+}
+
+static void DecodeLdi(Word Code) {
+	if(ChkArgCnt(2, 2)) {
+		if(ArgStr[1].Str[0] != 'r') WrError(ErrNum_InvFormat);
+		else if(ArgStr[2].Str[0] != '#') WrError(ErrNum_InvFormat);
+		else {
+			StrCompCutLeft(&ArgStr[1], 1);
+			StrCompCutLeft(&ArgStr[2], 1);
+			Boolean OK;
+			WAsmCode[0] = EvalStrIntExpression(&ArgStr[1], UInt4, &OK);
+			if(!OK) return;
+			if(WAsmCode[0] == 0) {
+				WrError(ErrNum_InvFormat);
+				return;
+			}
+			Word imm = EvalStrIntExpression(&ArgStr[2], UInt8, &OK);
+			if(!OK) return;
+			WAsmCode[0] |= imm << 8;
+			WAsmCode[0] |= Code;
+			CodeLen = 1;
+		}
+	}
+}
+
+static void DecodeCall(Word Code) {
+	if(ChkArgCnt(1, 1)) {
+		Boolean OK;
+		Word dest = EvalStrIntExpression(&ArgStr[1], UInt14, &OK);
+		if(OK) {
+			WAsmCode[0] = 0x005C;
+			WAsmCode[1] = J_CODE;
+			WAsmCode[1] |= (dest >> 8) & 0x3F;
+			WAsmCode[1] |= (dest & 0xFF) << 8;
+			CodeLen = 2;
+		}
+	}
+}
+
+static void AddFixed(char *NName, Word NCode) {
+	AddInstTable(InstTable, NName, NCode, DecodeFixed);
+}
+
+static void AddSingleReg(char *NName, Word NCode) {
+	AddInstTable(InstTable, NName, NCode, DecodeSingleReg);
+}
+
+static void AddBranch(char *NName, Word NCode) {
+	AddInstTable(InstTable, NName, NCode, DecodeBranch);
+}
+
+static void AddAri(char *NName, Word NCode) {
+	AddInstTable(InstTable, NName, NCode, DecodeAri);
+}
+
+static void AddLoadstore(char *NName, Word NCode) {
+	AddInstTable(InstTable, NName, NCode, DecodeLoadstore);
+}
+
+static void InitFields(void) {
+	InstTable = CreateInstTable(36);
+	
+	AddFixed("WAIT", 0xA05F);
+	AddFixed("RTI", 0xB05F);
+	AddFixed("LDC", 0xF05F);
+	AddFixed("RETURN", 0xD050);
+	AddFixed("NOP", 0x0055); //or r0,r0
+	
+	AddSingleReg("SR", 0x005F);
+	AddSingleReg("SRC", 0x105F);
+	AddSingleReg("SL", 0x205F);
+	AddSingleReg("SLC", 0x305F);
+	AddSingleReg("ROR", 0x405F);
+	AddSingleReg("ROL", 0x505F);
+	AddSingleReg("OUT", 0x705F);
+	AddSingleReg("IN", 0x805F);
+	AddSingleReg("GF", 0xD05F);
+	AddSingleReg("PF", 0xE05F);
+	
+	AddBranch("BNC", 0x0060);
+	AddBranch("BC", 0x0068);
+	AddBranch("BNZ", 0x0070);
+	AddBranch("BZ", 0x0078);
+	
+	AddAri("ADD", 0x0050 | SUPPORT_IMMEDIATE);
+	AddAri("ADC", 0x0051 | SUPPORT_IMMEDIATE);
+	AddAri("SUB", 0x0052 | SUPPORT_IMMEDIATE);
+	AddAri("SBC", 0x0053 | SUPPORT_IMMEDIATE);
+	AddAri("AND", 0x0054);
+	AddAri("OR", 0x0055);
+	AddAri("XOR", 0x0056);
+	AddAri("NOT", 0x0057);
+	
+	AddLoadstore("LD", 0x00C0);
+	AddLoadstore("ST", 0x0080);
+	
+	AddInstTable(InstTable, "IOA", 0x0040, DecodeIOA);
+	AddInstTable(InstTable, "MUL", 0xC05F, DecodeMul);
+	AddInstTable(InstTable, "J", J_CODE, DecodeJump);
+	AddInstTable(InstTable, "CMP", 0x000E, DecodeCmp);
+	AddInstTable(InstTable, "CALL", 0x0000, DecodeCall);
+	AddInstTable(InstTable, "LDI", 0x0040, DecodeLdi);
+}
+
+static void DeinitFields(void) {
+	DestroyInstTable(InstTable);
+}
+
+static void MakeCode_qcpu(void) {
+	CodeLen = 0; DontPrint = False;
+	
+	if(Memo("")) return;
+	
+	if(!LookupInstTable(InstTable, OpPart.Str)) WrStrErrorPos(ErrNum_UnknownInstruction, &OpPart);
+}
+
+static Boolean IsDef_qcpu(void) {
+	return Memo("REG");
+}
+
+static void SwitchFrom_qcpu(void) {
+	DeinitFields();
+}
+
+static void SwitchTo_qcpu(void) {
+	TurnWords = False;
+	ConstMode = ConstModeMoto;
+	SetIsOccupied = False;
+	
+	PCSymbol = "*";
+	HeaderID = 0x0089;
+	NOPCode = 0x0055; //or r0,r0
+	DivideChars = ",";
+	HasAttrs = False;
+	
+	ValidSegs = (1 << SegCode) + (1 << SegData);
+	Grans[SegCode] = 2; ListGrans[SegCode] = 2; SegInits[SegCode] = 0;
+	SegLimits[SegCode ] = 0x3fff;
+	
+	Grans[SegData] = 1; ListGrans[SegData] = 1; SegInits[SegData] = 0;
+	SegLimits[SegData ] = 0x3f;
+	
+	MakeCode = MakeCode_qcpu;
+	IsDef = IsDef_qcpu;
+	SwitchFrom = SwitchFrom_qcpu;
+	
+	InitFields();
+}
+
+void code_qcpu_init(void) {
+	CPUqcpu = AddCPU("QCPU", SwitchTo_qcpu);
+}
diff --git a/codeqcpu.h b/codeqcpu.h
new file mode 100644
index 0000000..dd13cf6
--- /dev/null
+++ b/codeqcpu.h
@@ -0,0 +1,4 @@
+#ifndef _CODEQCPU_H
+#define _CODEQCPU_H
+extern void code_qcpu_init(void);
+#endif
diff --git a/headids.c b/headids.c
index 5fd55e1..12573c4 100644
--- a/headids.c
+++ b/headids.c
@@ -149,6 +149,7 @@ static TFamilyDescr Descrs[] =
   { "i960"         , 0x002a, IntHex32 },
   { "8X30x"        , 0x003a, IntHex   },
   { "2650"         , 0x0037, MotoS    },
+  { "AS2650-2"     , 0x0087, MotoS    },
   { "XA"           , 0x003c, IntHex16 },
   { "AVR"          , 0x003b, Atmel    },
   { "29xxx"        , 0x0029, IntHex32 },
@@ -212,6 +213,7 @@ static TFamilyDescr Descrs[] =
   { "ATARI_VECTOR" , 0x0002, IntHex   },
   { "XCore"        , 0x0006, MotoS    },
   { "1750"         , 0x004f, IntHex   },
+  { "QCPU"         , 0x0089, IntHex   },
   { NULL           , 0xffff, Default  }
 };
 
diff --git a/makedefs.src b/makedefs.src
index 96d1068..970fd39 100644
--- a/makedefs.src
+++ b/makedefs.src
@@ -29,7 +29,7 @@ CODE_SRCS = codepseudo.c intpseudo.c motpseudo.c tipseudo.c natpseudo.c fourpseu
             code1802.c \
             codevector.c \
 	    codexcore.c \
-            code1750.c
+            code1750.c codeas2650-2.c codeqcpu.c
 
 DECODE_SRCS = deco68.c deco87c800.c
 
